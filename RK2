import math
import numpy as np
import pandas as pd
import random
import plotly.graph_objs as go


class Conus:
    fig = go.Figure()
    goldenAngle = 2.0 * np.pi * (1.0 - 1.0 / ((1 + 5 ** 0.5) / 2))

    def __init__(self, a, b, c):
        # построим конус
        self.a = a
        self.b = b
        self.c = c
        self.e = e
        u = np.linspace(0, c, 100)
        v = np.linspace(0, 2 * np.pi, 100)
        U, V = np.meshgrid(u, v)
        self.X, self.Y, self.Z = U * a * np.cos(V), U * b * np.sin(V), U

        # и его основанием
        self.x_ellipse = U * a * np.cos(V)
        self.y_ellipse = U * b * np.sin(V)
        self.z_ellipse = []
        for i in range(100):
            self.z_ellipse.append(np.repeat(c, 100))
        self.z_ellipse = np.array(self.z_ellipse)

        self.fig.add_surface(x=self.X, y=self.Y, z=self.Z)
        self.fig.add_surface(x=self.x_ellipse, y=self.y_ellipse, z=self.z_ellipse)
        # self.fig.show()

    def distribution_points(self, N):
        S_ellipse = math.pi * 2 * (self.a + self.b)
        S_conus_side = math.pi * (4 * self.a) * math.sqrt(self.a ** 2 + self.c ** 2)
        persent = S_ellipse / (S_ellipse + S_conus_side)
        points_on_ellipse = int(N * persent)
        points_on_side = int(N - points_on_ellipse)

        I = np.arange(0, points_on_ellipse, dtype=float) + random.uniform(0, 1)
        V = self.goldenAngle * I
        A = np.sqrt(I) / math.sqrt(points_on_ellipse) * self.a
        B = np.sqrt(I) / math.sqrt(points_on_ellipse) * self.b
        self.X = self.c * A * np.cos(V)
        self.Y = self.c * B * np.sin(V)
        self.Z = np.repeat(self.c, points_on_ellipse)
        self.fig.add_scatter3d(x=self.X, y=self.Y, z=self.Z)

        # точки на стороне
        I = np.arange(0, points_on_side, dtype=float) + random.uniform(0, 1)
        V = self.goldenAngle * I
        A = np.sqrt(I) / math.sqrt(points_on_side) * self.a
        B = np.sqrt(I) / math.sqrt(points_on_side) * self.b
        R = np.linspace(0, self.c, points_on_side)

        self.X = R * A * np.cos(V)
        self.Y = R * B * np.sin(V)
        self.Z = R
        self.fig.add_scatter3d(x=self.X, y=self.Y, z=self.Z)
        self.fig.show()

    def draw_sphere(self, xCenter, yCenter, zCenter, r):
        u, v = np.mgrid[0:2 * np.pi:20j, 0:np.pi:10j]
        x = np.cos(u) * np.sin(v)
        y = np.sin(u) * np.sin(v)
        z = np.cos(v)
        x = self.e * x + xCenter
        y = self.e * y + yCenter
        z = self.e * z + zCenter
        return x, y, z


a, b, c, e = 2, 2, 4, 0.1
A = Conus(a, b, c, e)

A.distribution_points(40)
A.draw
